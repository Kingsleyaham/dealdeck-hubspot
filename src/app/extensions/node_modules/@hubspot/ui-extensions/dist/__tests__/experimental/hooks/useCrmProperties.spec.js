import { renderHook, waitFor } from '@testing-library/react';
import { useCrmProperties } from '../../../experimental/hooks/useCrmProperties';
// Mock the logger module
jest.mock('../../../logger', () => ({
    logger: {
        debug: jest.fn(),
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
    },
}));
// Mock the fetchCrmProperties module
jest.mock('../../../experimental/crm/fetchCrmProperties');
const mockFetchCrmProperties = jest.fn();
import * as fetchCrmPropertiesModule from '../../../experimental/crm/fetchCrmProperties';
fetchCrmPropertiesModule.fetchCrmProperties = mockFetchCrmProperties;
describe('useCrmProperties', () => {
    let originalError;
    beforeAll(() => {
        // Suppress React act() warning coming from @testing-library/react
        originalError = console.error;
        console.error = (...args) => {
            if (args[0]?.includes('ReactDOMTestUtils.act'))
                return;
            originalError.call(console, ...args);
        };
    });
    beforeEach(() => {
        // Reset the mock before each test
        mockFetchCrmProperties.mockReset();
    });
    afterAll(() => {
        console.error = originalError;
    });
    it('should return the initial values for properties, error, and isLoading', async () => {
        const { result } = renderHook(() => useCrmProperties(['firstname', 'lastname']));
        await waitFor(() => {
            expect(result.current.properties).toEqual({});
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(true);
        });
    });
    it('should successfully fetch and return CRM properties', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            firstname: 'Test value for firstname',
            lastname: 'Test value for lastname',
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            });
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should handle fetch errors correctly', async () => {
        const errorMessage = 'Failed to fetch CRM properties';
        mockFetchCrmProperties.mockRejectedValue(new Error(errorMessage));
        const propertyNames = ['firstname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(result.current.error?.message).toBe(errorMessage);
            expect(result.current.properties).toEqual({});
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should update properties when propertiesUpdatedCallback is called', async () => {
        // Capture the callback so we can simulate an external update to CRM properties
        let capturedCallback;
        mockFetchCrmProperties.mockImplementation((_propertyNames, propertiesUpdatedCallback) => {
            capturedCallback = propertiesUpdatedCallback;
            return { firstname: 'Initial', lastname: 'Initial' };
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Initial',
                lastname: 'Initial',
            });
            expect(result.current.isLoading).toBe(false);
        });
        const updatedProperties = { firstname: 'Updated', lastname: 'Updated' };
        await waitFor(() => {
            if (capturedCallback) {
                capturedCallback(updatedProperties);
                expect(result.current.properties).toEqual(updatedProperties);
            }
        });
    });
});
