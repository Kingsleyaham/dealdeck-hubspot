// Set up the mock before importing the module
const mockFetchCrmProperties = jest.fn();
const mockSelf = {
    fetchCrmProperties: mockFetchCrmProperties,
};
// Mock the global self object
Object.defineProperty(global, 'self', {
    value: mockSelf,
    writable: true,
});
import { fetchCrmProperties, } from '../../../experimental/crm/fetchCrmProperties';
describe('fetchCrmProperties', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('successfully fetches CRM properties', async () => {
        const mockApiResponse = {
            firstname: 'Test value for firstname',
            lastname: 'Test value for lastname',
        };
        const mockResponse = {
            ok: true,
            json: jest.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname', 'lastname'];
        const result = await fetchCrmProperties(propertyNames, jest.fn());
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function));
        expect(result).toEqual({
            firstname: 'Test value for firstname',
            lastname: 'Test value for lastname',
        });
    });
    it('throws an error when response is not OK', async () => {
        const mockResponse = {
            ok: false,
            statusText: 'Not Found',
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, jest.fn())).rejects.toThrow('Failed to fetch CRM properties: Not Found');
    });
    it('throws an error when fetch fails', async () => {
        mockFetchCrmProperties.mockRejectedValue(new Error('Network error'));
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, jest.fn())).rejects.toThrow('Network error');
    });
    it('throws an error if the response is not an object', async () => {
        const mockApiResponse = 'Invalid response';
        const mockResponse = {
            ok: true,
            json: jest.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, jest.fn())).rejects.toThrow('Invalid response format');
    });
    it('passes the propertiesUpdatedCallback and allows it to be called', async () => {
        let capturedCallback;
        const mockApiResponse = {
            firstname: 'Initial',
            lastname: 'Initial',
        };
        const mockResponse = {
            ok: true,
            json: jest.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockImplementation((propertyNames, callback) => {
            capturedCallback = callback;
            return Promise.resolve(mockResponse);
        });
        const propertyNames = ['firstname', 'lastname'];
        const mockCallback = jest.fn();
        await fetchCrmProperties(propertyNames, mockCallback);
        expect(typeof capturedCallback).toBe('function');
        // Simulate the callback being called with new properties
        const updatedProps = { firstname: 'Updated', lastname: 'Updated' };
        if (capturedCallback) {
            capturedCallback(updatedProps);
        }
        expect(mockCallback).toHaveBeenCalledWith(updatedProps);
    });
});
